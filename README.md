# Tunnel Optimization

## Description
This project is a final assignment for the course in Combinatorial Optimization. It focuses on designing an efficient system of tunnels that connect various underground resource deposits in 3D space while avoiding underground water reservoirs. The objective is to minimize the total length of the tunnels, ensuring an optimal route that visits all the deposits and returns to the starting point without retracing any path. This problem is a modification of the classic Traveling Salesman Problem (TSP), with additional constraints to avoid specific areas representing underground water reservoirs.

## Problem Description
A mining planning specialist has been tasked with designing an efficient system of tunnels that will connect different underground resource deposits. The challenge is to optimally plan the routes to minimize the tunnel lengths while avoiding areas of underground water reservoirs, which could lead to technical difficulties, ecological risks, or hindered mining operations. The deposits must be connected in such a way that, by traversing the tunnels, it is possible to visit all deposits and return to the starting point without retracing.

The deposits are represented as points $P_i (x_i, y_i, z_i)$, and the water reservoirs are represented as spheres with center $S_i (x_i, y_i, z_i)$ and radius $r_i$.

## Mathematical Description

### Objective Function
The goal is to minimize the total length of the tunnels:

$\text{min}\sum_{i=1}^{n}\sum_{j\neq i, j=1}^{n} d_{ij} e_{ij}$

where:

- $d_{ij}$ is the distance between deposit $i$ and deposit $j$.
- $e_{ij}$ indicates whether a tunnel can be constructed between deposit $i$ and deposit $j$ (0 - cannot be constructed, 1 - can be constructed).

### Distance Calculation
The distance $d_{ij}$ between deposits $i$ and $j$ is given by:

$d_{ij} = \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2}$

### Collision Condition Check
The equation of the line segment between points $i$ and $j$ can be written as:

$P(t) = P_i + t \cdot (P_j - P_i)$

where $t$ is a parameter, and $P_i$ and $P_j$ are the endpoints of the segment.

The collision condition with a sphere centered at $S_k$ with radius $r_k$ can be expressed using the sphere equation:

$||P(t) - S_k||^2 = r_k^2$

where $||...||$ denotes the Euclidean norm.

By substituting the line segment equation into the sphere equation, we obtain:

$||P_i + t \cdot (P_j - P_i) - S_k||^2 = r_k^2$

This results in a quadratic equation in terms of the parameter $t$:

$a \cdot t^2 + b \cdot t + c = 0$

where:

- $a = ||P_j - P_i||^2$
- $b = 2 \cdot (P_j - P_i) \cdot (P_i - S_k)$
- $c = ||P_i - S_k||^2 - r_k^2$

### Discriminant Calculation
We calculate the discriminant $\Delta$:

$\Delta = b^2 - 4ac$

- If $\Delta < 0$, there is no collision.
- Otherwise, we compute $t_1$ and $t_2$:

$t_1 = \frac{-b + \sqrt{\Delta}}{2a}$

$t_2 = \frac{-b - \sqrt{\Delta}}{2a}$

- If $(0 \leq t_1 \leq 1)$ or $(0 \leq t_2 \leq 1)$, then the segment between points $P_i$ and $P_j$ collides with the sphere centered at $S_k$ with radius $r_k$.

### Tunnel Construction Condition
The condition to determine whether a tunnel can be constructed between points $i$ and $j$ is as follows:

$e_{ij} = 0 \quad \text{if} \quad ∃_{k}∃_{t_{1}}∃_{t_{2}} \quad (0 \leq t_1 \leq 1) \lor (0 \leq t_2 \leq 1), \quad \text{otherwise} \quad e_{ij} = 1$

## Algorithms and Instance Generator

### Instance Generator
The instance generator ensures that each generated instance includes at least one feasible solution. It works by generating random points in a 3D space, then selecting a permutation of these points that will form a valid solution (though not necessarily an optimal one). The lines connecting consecutive points in this permutation are ensured to be free of any obstacles. At the end of the permutation, the starting point is added again to guarantee a connection between the last and first points, forming a closed loop.

Obstacles are then generated by selecting two random points that are not adjacent in the solution permutation, ensuring unique selection for each obstacle. The center of the obstacle is randomly positioned between the chosen points, guaranteeing that at least one connection will be blocked. The radius of the obstacle is chosen to be smaller than the distance from its center to the nearest point, ensuring a realistic size for the obstacle.

The instance generator only creates obstacles that can potentially affect the generated solution, thereby limiting their number. The maximum number of obstacles for an instance with $n$ points is given by:

$\frac{n!}{2 \cdot (n-2)!} - n$

When the maximum number of obstacles is reached, only one solution exists for the instance.

### Algorithm A: Exhaustive Search (Brute Force)
This algorithm guarantees finding the optimal solution but has a very high time complexity of $O(n!)$, where $n$ is the number of points. The complexity arises from the need to generate all possible permutations of the points. The algorithm works by evaluating each permutation and checking whether the corresponding path is feasible (no obstacles block any of the connections). If the path is feasible, its total distance is calculated, and the permutation with the smallest distance is chosen as the optimal solution.

### Algorithm B: Greedy Approach
The greedy algorithm works by making locally optimal choices at each step, hoping that these decisions will lead to a globally optimal solution. In this problem, the locally optimal choice is to move to the nearest available point that is not blocked by an obstacle. At each step, the algorithm selects the closest point that can be reached without crossing any obstacles. Although this approach can be efficient with a time complexity of $O(n^2)$, where $n$ is the number of points, it may not always find a feasible solution, and when it does, the solution is not guaranteed to be optimal.

### Algorithm C: Randomized Greedy Approach
This algorithm is similar to the standard greedy approach but introduces randomness by considering the points in a random order (a random permutation). Instead of evaluating the points sequentially (0, 1, 2, 3…), the algorithm checks them in a random sequence, which can help explore a broader range of solutions. Like the standard greedy approach, it has a time complexity of $O(n^2)$, where $n$ is the number of points.

### Algorithm D: Tabu Search
Tabu Search is a metaheuristic algorithm that starts by generating a distance matrix, where the distances between points are calculated, and any connection blocked by an obstacle is marked as infinite. An initial random permutation of the points serves as the starting solution. The algorithm iteratively generates neighboring solutions by swapping the positions of two points in the permutation. Among the neighbors, the one with the shortest total distance is selected, provided it is not on the tabu list (a list used to avoid returning to recently visited solutions). If the new solution is better than the best-known solution, it replaces it as the current best solution. The process repeats for a predefined number of iterations. Although Tabu Search does not guarantee finding a feasible solution, and the found solution may not be optimal, it is effective for exploring large solution spaces. The time complexity of the algorithm is $O(m \cdot n^2 + x \cdot n^2)$, where $x$ is the maximum number of iterations, and $m \cdot n^2$ accounts for generating the distance matrix while $x \cdot n^2$ arises from generating neighborhoods in the Tabu Search process.

## Example Problem Instance and Solution

![Example Instance](instance.gif)

The GIF above demonstrates a sample problem instance and its solution. In the visualization:
- Black points represent the resource deposits.
- Connecting lines between the deposits represent the tunnels.
- Blue spheres represent the water reservoirs that must be avoided.

The objective of the problem is to connect all deposits with tunnels while minimizing their total length and avoiding any intersections with the water reservoirs.


## Acknowledgment

- [Travelling salesman problem](https://en.wikipedia.org/wiki/Travelling_salesman_problem)
- [Brute-force search](https://en.wikipedia.org/wiki/Brute-force_search)
- [Greedy algorithm](https://en.wikipedia.org/wiki/Greedy_algorithm)
- [Metaheuristic](https://en.wikipedia.org/wiki/Metaheuristic)
- [Tabu search](https://en.wikipedia.org/wiki/Tabu_search)
- [Matplotlib](https://matplotlib.org/)
- [NumPy](https://numpy.org/)
- [nlohmann/json](https://github.com/nlohmann/json)

## License

This project is open-source under the MIT License.
